"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var matchesState_1 = require("./matchesState");
var State_1 = require("./State");
var actions_1 = require("./actions");
var STATE_DELIMITER = '.';
var HISTORY_KEY = '$history';
var NULL_EVENT = '';
var STATE_IDENTIFIER = '#';
var isStateId = function (str) { return str[0] === STATE_IDENTIFIER; };
var emptyActions = Object.freeze({
    onEntry: [],
    onExit: [],
    actions: []
});
/**
 * Given a StateNode, walk up the parent chain until we find an
 * orthogonal region of a parallel state, or the top level machine
 * itself
 */
var regionOf = function (node) {
    // If we reach the top of the state machine, we're a "region".
    // If our parent is a parallel state, we're a region.
    while (node.parent && !node.parent.parallel) {
        node = node.parent;
    }
    return node;
};
/**
 * Ensure that the passed in StateNode instance belongs to a region
 * that previously had not been used, or that matches the existing
 * StateNode for the orthogonal regions.  This function is used to
 * verify that a transition that has multiple targets ends doesn't try
 * to target several states in the same orthogonal region.  The passed
 * state is added to the regions data structure using the state's
 * _region_ (see regionOf), and the region's parent.  If there is
 * already an object in the structure which is not already the state
 * in question, an Error is thrown, otherwise the state is added to
 * the structure, and the _region_ is returned.
 *
 * @param sourceState the state in which the event was triggered (used
 * to report error messages)
 * @param event the event that triggered the transition (used to
 * report error messages)
 * @param regions A data structure that retains the current set of
 * orthogonal regions (their IDs), grouped by their parallel state
 * (their IDs), with the values being the chosen states
 * @param state A state to add to the structure if possible.
 * @returns The region of the state, in order for the caller to repeat the process for the parent.
 * @throws Error if the region found already exists in the regions
 */
var ensureTargetStateIsInCorrectRegion = function (sourceState, event, regions, stateToCheck) {
    var region = regionOf(stateToCheck);
    var parent = region.parent;
    var parentId = parent ? parent.id : ''; // '' == machine
    regions[parentId] = regions[parentId] || {};
    if (regions[parentId][region.id] &&
        regions[parentId][region.id] !== stateToCheck) {
        throw new Error("Event '" + event + "' on state '" + sourceState.id + "' leads to an invalid configuration: " +
            ("Two or more states in the orthogonal region '" + region.id + "'."));
    }
    // Keep track of which state was chosen in a particular region.
    regions[parentId][region.id] = stateToCheck;
    return region;
};
var StateNode = /** @class */ (function () {
    function StateNode(config) {
        var _this = this;
        this.config = config;
        this.__cache = {
            events: undefined,
            relativeValue: new Map(),
            initialState: undefined
        };
        this.idMap = {};
        this.key = config.key || '(machine)';
        this.parent = config.parent;
        this.machine = this.parent ? this.parent.machine : this;
        this.path = this.parent ? this.parent.path.concat(this.key) : [];
        this.delimiter =
            config.delimiter ||
                (this.parent ? this.parent.delimiter : STATE_DELIMITER);
        this.id =
            config.id ||
                (this.machine
                    ? [this.machine.key].concat(this.path).join(this.delimiter)
                    : this.key);
        this.initial = config.initial;
        this.parallel = !!config.parallel;
        this.states = (config.states
            ? utils_1.mapValues(config.states, function (stateConfig, key) {
                var stateNode = new StateNode(__assign({}, stateConfig, { key: key, parent: _this }));
                Object.assign(_this.idMap, __assign((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));
                return stateNode;
                var _a;
            })
            : {});
        this.on = config.on ? this.formatTransitions(config.on) : {};
        this.strict = !!config.strict;
        this.onEntry = config.onEntry
            ? [].concat(config.onEntry)
            : undefined;
        this.onExit = config.onExit
            ? [].concat(config.onExit)
            : undefined;
        this.data = config.data;
        this.activities = config.activities;
    }
    StateNode.prototype.getStateNodes = function (state) {
        var _this = this;
        var stateValue = state instanceof State_1.State
            ? state.value
            : utils_1.toStateValue(state, this.delimiter);
        if (typeof stateValue === 'string') {
            var initialStateValue = this.getStateNode(stateValue).initial;
            return initialStateValue
                ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a))
                : [this.states[stateValue]];
        }
        var subStateKeys = Object.keys(stateValue);
        var subStateNodes = subStateKeys.map(function (subStateKey) {
            return _this.getStateNode(subStateKey);
        });
        return subStateNodes.concat(subStateKeys.reduce(function (allSubStateNodes, subStateKey) {
            var subStateNode = _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);
            return allSubStateNodes.concat(subStateNode);
        }, []));
        var _a;
    };
    StateNode.prototype.handles = function (event) {
        var eventType = utils_1.getEventType(event);
        return this.events.indexOf(eventType) !== -1;
    };
    StateNode.prototype.transition = function (state, event, extendedState) {
        var resolvedStateValue = typeof state === 'string'
            ? this.resolve(utils_1.pathToStateValue(this.getResolvedPath(state)))
            : state instanceof State_1.State ? state : this.resolve(state);
        if (this.strict) {
            var eventType = utils_1.getEventType(event);
            if (this.events.indexOf(eventType) === -1) {
                throw new Error("Machine '" + this.id + "' does not accept event '" + eventType + "'");
            }
        }
        var currentState = State_1.State.from(resolvedStateValue);
        var stateTransition = this.transitionStateValue(currentState, event, currentState, extendedState);
        var nextState = this.stateTransitionToState(stateTransition, currentState);
        if (!nextState) {
            return State_1.State.inert(currentState);
        }
        var maybeNextState = nextState;
        var raisedEvents = nextState.actions.filter(function (action) { return typeof action === 'object' && action.type === actions_1.actionTypes.raise; });
        if (raisedEvents.length) {
            var raisedEvent = raisedEvents[0].event;
            nextState = this.transition(nextState, raisedEvent, extendedState);
            (_a = nextState.actions).unshift.apply(_a, nextState.actions);
            return nextState;
        }
        if (stateTransition.events.length) {
            var raised = stateTransition.events[0].type === actions_1.actionTypes.raise
                ? stateTransition.events[0].event
                : undefined;
            var nullEvent = stateTransition.events[0].type === actions_1.actionTypes.null;
            if (raised || nullEvent) {
                maybeNextState = this.transition(nextState, nullEvent ? NULL_EVENT : raised, extendedState);
                (_b = maybeNextState.actions).unshift.apply(_b, nextState.actions);
                return maybeNextState;
            }
        }
        return nextState;
        var _a, _b;
    };
    StateNode.prototype.stateTransitionToState = function (stateTransition, prevState) {
        var nextStatePaths = stateTransition.statePaths, nextActions = stateTransition.actions, nextActivities = stateTransition.activities, events = stateTransition.events;
        if (!nextStatePaths.length) {
            return undefined;
        }
        var prevActivities = prevState instanceof State_1.State ? prevState.activities : undefined;
        var activities = __assign({}, prevActivities, nextActivities);
        var nextStateValue = this.resolve(utils_1.pathsToStateValue(nextStatePaths));
        return new State_1.State(
        // next state value
        nextStateValue, 
        // history
        State_1.State.from(prevState), 
        // effects
        nextActions
            ? nextActions.onExit
                .concat(nextActions.actions)
                .concat(nextActions.onEntry)
            : [], 
        // activities
        activities, 
        // data
        this.getStateNodes(nextStateValue).reduce(function (data, stateNode) {
            if (stateNode.data !== undefined) {
                data[stateNode.id] = stateNode.data;
            }
            return data;
        }, {}), events);
    };
    StateNode.prototype.getStateNode = function (stateKey) {
        if (isStateId(stateKey)) {
            return this.machine.getStateNodeById(stateKey);
        }
        if (!this.states) {
            throw new Error("Unable to retrieve child state '" + stateKey + "' from '" + this
                .id + "'; no child states exist.");
        }
        var result = this.states[stateKey];
        if (!result) {
            throw new Error("Child state '" + stateKey + "' does not exist on '" + this.id + "'");
        }
        return result;
    };
    StateNode.prototype.getStateNodeById = function (stateId) {
        var resolvedStateId = isStateId(stateId)
            ? stateId.slice(STATE_IDENTIFIER.length)
            : stateId;
        var stateNode = this.idMap[resolvedStateId];
        if (!stateNode) {
            throw new Error("Substate '#" + resolvedStateId + "' does not exist on '" + this.id + "'");
        }
        return stateNode;
    };
    StateNode.prototype.resolve = function (stateValue) {
        var _this = this;
        if (typeof stateValue === 'string') {
            var subStateNode = this.getStateNode(stateValue);
            return subStateNode.initial
                ? (_a = {}, _a[stateValue] = subStateNode.initialStateValue, _a) : stateValue;
        }
        if (this.parallel) {
            return utils_1.mapValues(this.initialStateValue, function (subStateValue, subStateKey) {
                return _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue);
            });
        }
        return utils_1.mapValues(stateValue, function (subStateValue, subStateKey) {
            return _this.getStateNode(subStateKey).resolve(subStateValue);
        });
        var _a;
    };
    StateNode.prototype.transitionStateValue = function (state, event, fullState, extendedState) {
        var _this = this;
        var history = state.history;
        var stateValue = state.value;
        if (typeof stateValue === 'string') {
            var subStateNode = this.getStateNode(stateValue);
            var result = subStateNode.next(event, fullState, history ? history.value : undefined, extendedState);
            // If a machine substate returns no potential transitions,
            // check on the machine itself.
            if (!result.statePaths.length && !this.parent) {
                return this.next(event, fullState, history ? history.value : undefined, extendedState);
            }
            return result;
        }
        // Potential transition tuples from parent state nodes
        var potentialStateTransitions = [];
        var willTransition = false;
        var nextStateTransitionMap = utils_1.mapValues(stateValue, function (subStateValue, subStateKey) {
            var subStateNode = _this.getStateNode(subStateKey);
            var subHistory = history ? history.value[subStateKey] : undefined;
            var subState = new State_1.State(subStateValue, subHistory ? State_1.State.from(subHistory) : undefined);
            var subStateTransition = subStateNode.transitionStateValue(subState, event, fullState, extendedState);
            if (!subStateTransition.statePaths.length) {
                potentialStateTransitions.push(subStateNode.next(event, fullState, history ? history.value : undefined, extendedState));
            }
            else {
                willTransition = true;
            }
            return subStateTransition;
        });
        if (!willTransition) {
            if (this.parallel) {
                if (potentialStateTransitions.length) {
                    // Select the first potential state transition to take
                    return potentialStateTransitions[0];
                }
                return {
                    statePaths: [],
                    actions: emptyActions,
                    activities: undefined,
                    events: []
                };
            }
            var subStateKey = Object.keys(nextStateTransitionMap)[0];
            // try with parent
            var _a = this.getStateNode(subStateKey).next(event, fullState, history ? history.value : undefined, extendedState), parentStatePaths = _a.statePaths, parentNextActions = _a.actions, parentActivities = _a.activities;
            var nextActions = nextStateTransitionMap[subStateKey].actions;
            var activities = nextStateTransitionMap[subStateKey].activities;
            var allActivities = __assign({}, activities, parentActivities);
            var allActions = parentNextActions
                ? nextActions
                    ? {
                        onEntry: nextActions.onEntry.concat(parentNextActions.onEntry),
                        actions: nextActions.actions.concat(parentNextActions.actions),
                        onExit: nextActions.onExit.concat(parentNextActions.onExit)
                    }
                    : parentNextActions
                : nextActions;
            return {
                statePaths: parentStatePaths,
                actions: allActions,
                activities: allActivities,
                events: []
            };
        }
        if (this.parallel) {
            nextStateTransitionMap = __assign({}, utils_1.mapValues(this.initialState.value, function (subStateValue, key) {
                var subStateTransition = nextStateTransitionMap[key];
                return {
                    statePaths: subStateTransition && subStateTransition.statePaths.length
                        ? subStateTransition.statePaths
                        : utils_1.toStatePaths(stateValue[key] || subStateValue).map(function (subPath) { return _this.getStateNode(key).path.concat(subPath); }),
                    actions: subStateTransition && subStateTransition.actions
                        ? subStateTransition.actions
                        : {
                            onEntry: [],
                            onExit: [],
                            actions: []
                        },
                    activities: undefined,
                    events: []
                };
            }));
        }
        var finalActions = {
            onEntry: [],
            actions: [],
            onExit: []
        };
        var finalActivities = {};
        utils_1.mapValues(nextStateTransitionMap, function (subStateTransition) {
            var 
            // statePaths: nextSubStatePaths,
            nextSubActions = subStateTransition.actions, nextSubActivities = subStateTransition.activities;
            if (nextSubActions) {
                if (nextSubActions.onEntry) {
                    (_a = finalActions.onEntry).push.apply(_a, nextSubActions.onEntry);
                }
                if (nextSubActions.actions) {
                    (_b = finalActions.actions).push.apply(_b, nextSubActions.actions);
                }
                if (nextSubActions.onExit) {
                    (_c = finalActions.onExit).push.apply(_c, nextSubActions.onExit);
                }
            }
            if (nextSubActivities) {
                Object.assign(finalActivities, nextSubActivities);
            }
            var _a, _b, _c;
        });
        return {
            statePaths: Object.keys(nextStateTransitionMap)
                .map(function (stateKey) { return nextStateTransitionMap[stateKey].statePaths; })
                .reduce(function (a, b) { return a.concat(b); }, []),
            actions: finalActions,
            activities: finalActivities,
            events: []
        };
    };
    StateNode.prototype.next = function (event, fullState, history, extendedState) {
        var _this = this;
        var eventType = utils_1.getEventType(event);
        var actionMap = { onEntry: [], onExit: [], actions: [] };
        var activityMap = {};
        var candidates = this.on[eventType];
        if (this.onExit) {
            actionMap.onExit = this.onExit;
        }
        if (this.activities) {
            this.activities.forEach(function (activity) {
                activityMap[utils_1.getEventType(activity)] = false;
                actionMap.onExit = actionMap.onExit.concat(actions_1.stop(activity));
            });
        }
        if (!candidates) {
            return {
                statePaths: [],
                actions: actionMap,
                activities: activityMap,
                events: []
            };
        }
        var nextStateStrings = [];
        for (var _i = 0, candidates_1 = candidates; _i < candidates_1.length; _i++) {
            var candidate = candidates_1[_i];
            var _a = candidate, cond = _a.cond, stateIn = _a.in, transitionActions = _a.actions;
            var extendedStateObject = extendedState || {};
            var eventObject = actions_1.toEventObject(event);
            var isInState = stateIn
                ? matchesState_1.matchesState(utils_1.toStateValue(stateIn, this.delimiter), utils_1.path(this.path.slice(0, -2))(fullState.value))
                : true;
            if ((!cond || cond(extendedStateObject, eventObject)) &&
                (!stateIn || isInState)) {
                nextStateStrings = Array.isArray(candidate.target)
                    ? candidate.target
                    : [candidate.target];
                if (transitionActions) {
                    actionMap.actions = actionMap.actions.concat(transitionActions);
                }
                break;
            }
        }
        if (nextStateStrings.length === 0) {
            return {
                statePaths: [],
                actions: actionMap,
                activities: activityMap,
                events: []
            };
        }
        var finalPaths = [];
        var raisedEvents = [];
        var usedRegions = {};
        nextStateStrings.forEach(function (nextStateString) {
            var nextStatePath = _this.getResolvedPath(nextStateString);
            var currentState = isStateId(nextStateString)
                ? _this.machine
                : _this.parent;
            var currentHistory = history;
            var currentPath = _this.key;
            nextStatePath.forEach(function (subPath) {
                if (subPath === '') {
                    actionMap.onExit = [];
                    currentState = _this;
                    return;
                }
                if (!currentState || !currentState.states) {
                    throw new Error("Unable to read '" + subPath + "' from '" + _this.id + "'");
                }
                if (subPath === HISTORY_KEY) {
                    if (!Object.keys(currentState.states).length) {
                        subPath = '';
                    }
                    else if (currentHistory) {
                        subPath =
                            typeof currentHistory === 'object'
                                ? Object.keys(currentHistory)[0]
                                : currentHistory;
                    }
                    else if (currentState.initial) {
                        subPath = currentState.initial;
                    }
                    else {
                        throw new Error("Cannot read '" + HISTORY_KEY + "' from state '" + currentState.id + "': missing 'initial'");
                    }
                }
                try {
                    if (subPath !== '') {
                        currentState = currentState.getStateNode(subPath);
                    }
                }
                catch (e) {
                    throw new Error("Event '" + event + "' on state '" + currentPath + "' leads to undefined state '" + nextStatePath.join(_this.delimiter) + "'.");
                }
                if (currentState.onEntry) {
                    actionMap.onEntry = actionMap.onEntry.concat(currentState.onEntry);
                }
                if (currentState.activities) {
                    currentState.activities.forEach(function (activity) {
                        activityMap[utils_1.getEventType(activity)] = true;
                        actionMap.onEntry = actionMap.onEntry.concat(actions_1.start(activity));
                    });
                }
                currentPath = subPath;
                if (currentHistory) {
                    currentHistory = currentHistory[subPath];
                }
            });
            if (!currentState) {
                throw new Error('no state');
            }
            var region = ensureTargetStateIsInCorrectRegion(_this, event, usedRegions, currentState);
            while (region.parent) {
                region = ensureTargetStateIsInCorrectRegion(_this, event, usedRegions, region.parent);
            }
            var paths = [currentState.path];
            if (currentState.initial || currentState.parallel) {
                var initialState = currentState.initialState;
                actionMap.onEntry = actionMap.onEntry.concat(initialState.actions);
                paths = utils_1.toStatePaths(initialState.value).map(function (subPath) {
                    return currentState.path.concat(subPath);
                });
            }
            finalPaths.push.apply(finalPaths, paths);
            while (currentState.initial) {
                if (!currentState || !currentState.states) {
                    throw new Error("Invalid initial state");
                }
                currentState = currentState.states[currentState.initial];
                if (currentState.activities) {
                    currentState.activities.forEach(function (activity) {
                        activityMap[utils_1.getEventType(activity)] = true;
                        actionMap.onEntry = actionMap.onEntry.concat(actions_1.start(activity));
                    });
                }
            }
            var myActions = (currentState.onEntry
                ? currentState.onEntry.filter(function (action) {
                    return typeof action === 'object' && action.type === actions_1.actionTypes.raise;
                })
                : []).concat(currentState.on[NULL_EVENT] ? { type: actions_1.actionTypes.null } : []);
            myActions.forEach(function (action) { return raisedEvents.push(action); });
        });
        return {
            statePaths: finalPaths,
            actions: actionMap,
            activities: activityMap,
            events: raisedEvents
        };
    };
    Object.defineProperty(StateNode.prototype, "resolvedStateValue", {
        get: function () {
            var key = this.key;
            if (this.parallel) {
                return _a = {},
                    _a[key] = utils_1.mapValues(this.states, function (stateNode) { return stateNode.resolvedStateValue[stateNode.key]; }),
                    _a;
            }
            if (!this.initial) {
                // If leaf node, value is just the state node's key
                return key;
            }
            return _b = {},
                _b[key] = this.states[this.initial].resolvedStateValue,
                _b;
            var _a, _b;
        },
        enumerable: true,
        configurable: true
    });
    StateNode.prototype.getResolvedPath = function (stateIdentifier) {
        if (isStateId(stateIdentifier)) {
            var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];
            if (!stateNode) {
                throw new Error("Unable to find state node '" + stateIdentifier + "'");
            }
            return stateNode.path;
        }
        return utils_1.toStatePath(stateIdentifier, this.delimiter);
    };
    Object.defineProperty(StateNode.prototype, "initialStateValue", {
        get: function () {
            var initialStateValue = this.__cache.initialState ||
                (this.parallel
                    ? utils_1.mapValues(this.states, function (state) { return state.initialStateValue; })
                    : typeof this.resolvedStateValue === 'string'
                        ? undefined
                        : this.resolvedStateValue[this.key]);
            this.__cache.initialState = initialStateValue;
            return this.__cache.initialState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateNode.prototype, "initialState", {
        get: function () {
            var initialStateValue = this.initialStateValue;
            if (!initialStateValue) {
                throw new Error("Cannot retrieve initial state from simple state '" + this.id + ".'");
            }
            var activityMap = {};
            var actions = [];
            this.getStateNodes(initialStateValue).forEach(function (stateNode) {
                if (stateNode.onEntry) {
                    actions.push.apply(actions, stateNode.onEntry);
                }
                if (stateNode.activities) {
                    stateNode.activities.forEach(function (activity) {
                        activityMap[utils_1.getEventType(activity)] = true;
                        actions.push(actions_1.start(activity));
                    });
                }
            });
            return new State_1.State(initialStateValue, undefined, actions, activityMap);
        },
        enumerable: true,
        configurable: true
    });
    StateNode.prototype.getStates = function (stateValue) {
        var _this = this;
        if (typeof stateValue === 'string') {
            return [this.states[stateValue]];
        }
        var stateNodes = [];
        Object.keys(stateValue).forEach(function (key) {
            stateNodes.push.apply(stateNodes, _this.states[key].getStates(stateValue[key]));
        });
        return stateNodes;
    };
    StateNode.prototype.getState = function (relativeStateId) {
        if (typeof relativeStateId === 'string' && isStateId(relativeStateId)) {
            return this.getStateNodeById(relativeStateId);
        }
        var statePath = utils_1.toStatePath(relativeStateId, this.delimiter);
        try {
            return statePath.reduce(function (subState, subPath) {
                if (!subState.states) {
                    throw new Error("Cannot retrieve subPath '" + subPath + "' from node with no states");
                }
                return subState.states[subPath];
            }, this);
        }
        catch (e) {
            throw new Error("State '" + relativeStateId + " does not exist on machine '" + this.id + "'");
        }
    };
    Object.defineProperty(StateNode.prototype, "events", {
        get: function () {
            if (this.__cache.events) {
                return this.__cache.events;
            }
            var states = this.states;
            var events = new Set(Object.keys(this.on));
            if (states) {
                Object.keys(states).forEach(function (stateId) {
                    var state = states[stateId];
                    if (state.states) {
                        for (var _i = 0, _a = state.events; _i < _a.length; _i++) {
                            var event_1 = _a[_i];
                            events.add("" + event_1);
                        }
                    }
                });
            }
            return (this.__cache.events = Array.from(events));
        },
        enumerable: true,
        configurable: true
    });
    StateNode.prototype.formatTransitions = function (onConfig) {
        return utils_1.mapValues(onConfig, function (value) {
            if (value === undefined) {
                return [];
            }
            if (Array.isArray(value)) {
                return value;
            }
            if (typeof value === 'string') {
                return [{ target: value }];
            }
            return Object.keys(value).map(function (target) {
                return __assign({ target: target }, value[target]);
            });
        });
    };
    return StateNode;
}());
exports.StateNode = StateNode;
function Machine(config) {
    return new StateNode(config);
}
exports.Machine = Machine;
